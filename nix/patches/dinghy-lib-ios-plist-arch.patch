diff --git a/dinghy-lib-0.8.4/src/apple/device.rs b/dinghy-lib-0.8.4/src/apple/device.rs
index f36278c..44ef8da 100644
--- a/dinghy-lib-0.8.4/src/apple/device.rs
+++ b/dinghy-lib-0.8.4/src/apple/device.rs
@@ -517,6 +517,22 @@ fn make_apple_app(
     sim_type: Option<&AppleSimulatorType>,
 ) -> Result<BuildBundle> {
     use crate::project;
+
+    fn arch_from_file_output(magic: &str) -> &str {
+        // `file` output format varies by macOS versions.
+        //
+        // Example (macOS 15+):
+        //   "Mach-O 64-bit arm64 executable, flags:<...>"
+        //
+        // Older dinghy versions used the last whitespace-separated token, which can be:
+        //   "flags:<...>"
+        for candidate in ["arm64e", "arm64", "x86_64", "i386", "armv7", "armv7s"] {
+            if magic.contains(candidate) {
+                return candidate;
+            }
+        }
+        // Conservative fallback: iOS devices are arm64; simulator builds are handled separately.
+        "arm64"
+    }
+
     let build_bundle = make_remote_app_with_name(project, build, Some("Dinghy.app"))?;
     project::rec_copy(&runnable.exe, build_bundle.bundle_dir.join("Dinghy"), false)?;
     let magic = process::Command::new("file")
@@ -529,12 +545,8 @@ fn make_apple_app(
         )
         .log_invocation(3)
         .output()?;
-    let magic = String::from_utf8(magic.stdout)?;
-    let target = magic
-        .split(" ")
-        .last()
-        .ok_or_else(|| anyhow!("empty magic"))?;
-    xcode::add_plist_to_app(&build_bundle, target, app_id, sim_type)?;
+    let magic = String::from_utf8(magic.stdout)?;
+    xcode::add_plist_to_app(&build_bundle, arch_from_file_output(&magic), app_id, sim_type)?;
     Ok(build_bundle)
 }

diff --git a/dinghy-lib-0.8.4/src/apple/xcode.rs b/dinghy-lib-0.8.4/src/apple/xcode.rs
index 6ae5b59..0b57aa3 100644
--- a/dinghy-lib-0.8.4/src/apple/xcode.rs
+++ b/dinghy-lib-0.8.4/src/apple/xcode.rs
@@ -9,6 +9,24 @@ use crate::utils::LogCommandExt;
 use crate::BuildBundle;
 
 pub fn add_plist_to_app(
     bundle: &BuildBundle,
     arch: &str,
     app_bundle_id: &str,
     sim_type: Option<&AppleSimulatorType>,
 ) -> Result<()> {
+    fn xml_escape(s: &str) -> String {
+        let mut out = String::with_capacity(s.len());
+        for ch in s.chars() {
+            match ch {
+                '&' => out.push_str("&amp;"),
+                '<' => out.push_str("&lt;"),
+                '>' => out.push_str("&gt;"),
+                '"' => out.push_str("&quot;"),
+                '\'' => out.push_str("&apos;"),
+                _ => out.push(ch),
+            }
+        }
+        out
+    }
+
+    let arch = xml_escape(arch);
+    let app_bundle_id = xml_escape(app_bundle_id);
     let mut plist = fs::File::create(bundle.bundle_dir.join("Info.plist"))?;
@@ -29,19 +47,19 @@ pub fn add_plist_to_app(
     writeln!(
         plist,
         "<key>CFBundleIdentifier</key><string>{}</string>",
+        app_bundle_id
     )?;
     writeln!(plist, "<key>CFBundleVersion</key>")?;
-    writeln!(plist, "<string>{}</string>", arch)?;
+    writeln!(plist, "<string>1</string>")?;
     writeln!(plist, "<key>CFBundleShortVersionString</key>")?;
-    writeln!(plist, "<string>{}</string>", arch)?;
+    writeln!(plist, "<string>1.0</string>")?;
     match sim_type {
         // The iOS/tvOS simulator have the same plist as an iOS device.
         Some(AppleSimulatorType::Ios) | Some(AppleSimulatorType::Tvos) | None => {
             writeln!(plist, "<key>UIRequiredDeviceCapabilities</key>")?;
             writeln!(plist, "<array><string>{}</string></array>", arch)?;
             writeln!(plist, "<key>UILaunchStoryboardName</key>")?;
             writeln!(plist, "<string></string>")?;
         }
         Some(AppleSimulatorType::Watchos) => {
             writeln!(plist, "<key>MinimumOSVersion</key><string>8.0</string>",)?;
             writeln!(plist, "<key>WKApplication</key><true/>",)?;
             writeln!(plist, "<key>WKWatchOnly</key><true/>")?;
         }
     }
     writeln!(plist, r#"</dict></plist>"#)?;
     Ok(())
 }
