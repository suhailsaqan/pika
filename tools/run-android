#!/usr/bin/env bash
set -euo pipefail

# One-command Android dev loop:
# - ensure emulator/device
# - build + install
# - launch app

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT"

# shellcheck disable=SC1091
source "$ROOT/tools/lib/dotenv.sh"
load_dotenv_no_override "$ROOT"

# If the user isn't in the devShell, re-exec under Nix for a consistent toolchain.
if [ -z "${IN_NIX_SHELL:-}" ] && [ "${PIKA_RUN_ANDROID_NO_NIX:-0}" != "1" ]; then
  qargs=()
  for a in "$@"; do qargs+=("$(printf '%q' "$a")"); done
  exec nix develop -c bash -lc "cd \"$ROOT\"; ./tools/run-android ${qargs[*]}"
fi

ADB="${ADB:-adb}"
APP_ID="${PIKA_ANDROID_APP_ID:-com.justinmoon.pika.dev}"
SERIAL="${PIKA_ANDROID_SERIAL:-}"
MODE="auto" # auto|emulator|device

usage() {
  cat <<EOF
usage: ./tools/run-android [--emulator|--device] [--serial <adb-serial>] [--list-targets]

Defaults:
  - If an emulator exists or can be started, we run on the emulator.
  - Otherwise we run on a single connected physical device.

Examples:
  ./tools/run-android --emulator
  ./tools/run-android --device
  ./tools/run-android --serial emulator-5554
  ./tools/run-android --serial <physical-serial>
  ./tools/run-android --list-targets

Env:
  PIKA_ANDROID_SERIAL   (same as --serial)
  PIKA_ANDROID_APP_ID   (default: $APP_ID)
EOF
}

list_targets() {
  local emus devs
  emus="$("$ADB" devices 2>/dev/null | awk 'NR>1 && $2=="device" && $1 ~ /^emulator-/ {print $1}')"
  devs="$("$ADB" devices 2>/dev/null | awk 'NR>1 && $2=="device" && $1 !~ /^emulator-/ {print $1}')"

  echo "Android targets:"
  if [ -n "${emus:-}" ]; then
    echo "$emus" | sed 's/^/  emulator: /'
  fi
  if [ -n "${devs:-}" ]; then
    echo "$devs" | sed 's/^/  device:   /'
  fi
  if [ -z "${emus:-}" ] && [ -z "${devs:-}" ]; then
    echo "  (none)"
  fi
}

while [ $# -gt 0 ]; do
  case "$1" in
    --emulator) MODE="emulator" ;;
    --device) MODE="device" ;;
    --serial)
      shift
      if [ $# -lt 1 ]; then echo "error: --serial requires a value" >&2; exit 2; fi
      SERIAL="$1"
      ;;
    --list-targets) list_targets; exit 0 ;;
    -h|--help) usage; exit 0 ;;
    *)
      echo "error: unknown arg: $1" >&2
      usage >&2
      exit 2
      ;;
  esac
  shift
done

ensure_emulator() {
  # Default UX: use an emulator (like iOS uses a simulator) unless the user explicitly
  # targets a physical device via PIKA_ANDROID_SERIAL or disables emulator startup.
  if [ "$MODE" = "device" ]; then
    PIKA_ANDROID_SKIP_EMULATOR=1 ./tools/android-emulator-ensure
    return 0
  fi
  if [ -n "${SERIAL:-}" ] && ! echo "$SERIAL" | grep -q '^emulator-'; then
    PIKA_ANDROID_SKIP_EMULATOR=1 ./tools/android-emulator-ensure
  else
    ./tools/android-emulator-ensure
  fi
}

ensure_emulator

serial_exists() {
  "$ADB" devices 2>/dev/null | awk 'NR>1 && $2=="device" {print $1}' | grep -Fxq "$1"
}

pick_emulators() {
  "$ADB" devices 2>/dev/null | awk 'NR>1 && $2=="device" && $1 ~ /^emulator-/ {print $1}'
}

pick_devices() {
  "$ADB" devices 2>/dev/null | awk 'NR>1 && $2=="device" && $1 !~ /^emulator-/ {print $1}'
}

pick_one_or_error() {
  local label="$1"
  local items="$2"
  local count
  count="$(echo "$items" | sed '/^$/d' | wc -l | tr -d '[:space:]')"
  if [ "${count:-0}" = "1" ]; then
    echo "$items" | sed '/^$/d' | head -n 1
    return 0
  fi
  if [ "${count:-0}" -gt 1 ]; then
    echo "error: multiple android $label targets available; choose one via --serial or PIKA_ANDROID_SERIAL:" >&2
    echo "$items" | sed '/^$/d' | sed 's/^/  /' >&2
    exit 2
  fi
  echo ""
}

if [ -n "${SERIAL:-}" ]; then
  if ! serial_exists "$SERIAL"; then
    echo "error: requested android serial not connected: $SERIAL" >&2
    list_targets >&2
    exit 2
  fi
else
  if [ "$MODE" = "emulator" ] || [ "$MODE" = "auto" ]; then
    SERIAL="$(pick_one_or_error "emulator" "$(pick_emulators)")"
  fi
  if [ -z "${SERIAL:-}" ]; then
    SERIAL="$(pick_one_or_error "device" "$(pick_devices)")"
  fi
fi
if [ -z "${SERIAL:-}" ]; then
  echo "error: no android device/emulator connected after ensure step" >&2
  list_targets >&2
  exit 1
fi
if echo "$SERIAL" | grep -q '^emulator-'; then
  echo "using android emulator: $SERIAL"
else
  echo "using android device: $SERIAL"
fi

# Build (via Gradle) then install deterministically onto the selected device.
just android-assemble

APK="$ROOT/android/app/build/outputs/apk/debug/app-debug.apk"
if [ ! -f "$APK" ]; then
  echo "error: expected apk not found: $APK" >&2
  exit 1
fi

if ! "$ADB" -s "$SERIAL" install -r "$APK" >/dev/null; then
  echo "error: adb install failed" >&2
  echo "hint: if you previously installed a differently-signed build, uninstall the old package:" >&2
  echo "  adb -s $SERIAL uninstall $APP_ID" >&2
  echo "note: this debug build uses applicationIdSuffix '.dev' (package: $APP_ID)" >&2
  exit 1
fi

maybe_setup_adb_reverse() {
  # Optional host->emulator port wiring to mimic "app can reach localhost services":
  #   PIKA_ADB_REVERSE_PORTS="32820"               # device 32820 -> host 32820
  #   PIKA_ADB_REVERSE_PORTS="18080:32820,9090"   # device 18080 -> host 32820; device 9090 -> host 9090
  local ports="${PIKA_ADB_REVERSE_PORTS:-${PIKA_ADB_REVERSE:-}}"
  if [ -z "${ports:-}" ]; then
    return 0
  fi

  IFS=',' read -r -a items <<<"$ports"
  for item in "${items[@]}"; do
    item="$(echo "$item" | tr -d '[:space:]')"
    if [ -z "$item" ]; then
      continue
    fi
    local dev_port host_port
    if echo "$item" | grep -q ':'; then
      dev_port="${item%%:*}"
      host_port="${item##*:}"
    else
      dev_port="$item"
      host_port="$item"
    fi
    echo "adb reverse tcp:${dev_port} -> tcp:${host_port}"
    "$ADB" -s "$SERIAL" reverse "tcp:${dev_port}" "tcp:${host_port}" >/dev/null
  done
}

maybe_setup_adb_reverse

maybe_write_config() {
  # Dev-friendly defaults:
  # - If no relay env vars are provided, we write a default relay config that works with
  #   the deployed OpenClaw/Marmot bot (public relays + separate key-package relays).
  #
  # Override:
  #   PIKA_RELAY_URLS="ws://10.0.2.2:18080" just run-android
  #   PIKA_KEY_PACKAGE_RELAY_URLS="wss://..." just run-android
  #
  # Disable:
  #   PIKA_NO_RELAY_OVERRIDE=1 just run-android
  # This writes `pika_config.json` into the app sandbox via `run-as` (debug builds only).
  if [ "${PIKA_NO_RELAY_OVERRIDE:-0}" = "1" ]; then
    return 0
  fi

  local relays="${PIKA_RELAY_URLS:-${PIKA_RELAY_URL:-}}"
  local kp_relays="${PIKA_KEY_PACKAGE_RELAY_URLS:-${PIKA_KP_RELAY_URLS:-}}"
  # Default to the deployed anonymous MOQ relay; override with PIKA_CALL_MOQ_URL for local setups.
  local call_moq_url="${PIKA_CALL_MOQ_URL:-https://us-east.moq.logos.surf/anon}"
  local call_broadcast_prefix="${PIKA_CALL_BROADCAST_PREFIX:-pika/calls}"
  local moq_probe_on_start="${PIKA_MOQ_PROBE_ON_START:-0}"

  # Defaults aimed at quick-start interop with the deployed Rust bot.
  if [ -z "${relays:-}" ]; then
    relays="wss://relay.primal.net,wss://nos.lol,wss://relay.damus.io"
  fi
  if [ -z "${kp_relays:-}" ]; then
    kp_relays="wss://nostr-pub.wellorder.net,wss://nostr-01.yakihonne.com,wss://nostr-02.yakihonne.com,wss://relay.satlantis.io"
  fi

  # Comma-separated list -> JSON array.
  local json
  json="$(
    python3 - <<PY
import json
relays = "${relays}".strip()
kp_relays = "${kp_relays}".strip()
relay_items = [x.strip() for x in relays.split(",") if x.strip()]
kp_items = [x.strip() for x in kp_relays.split(",") if x.strip()]
print(json.dumps({
  "disable_network": False,
  "relay_urls": relay_items,
  "key_package_relay_urls": kp_items,
  "call_moq_url": "${call_moq_url}",
  "call_broadcast_prefix": "${call_broadcast_prefix}",
  "moq_probe_on_start": True if "${moq_probe_on_start}" == "1" else False,
}))
PY
  )"

  echo "writing relay override to app config (pika_config.json)"
  "$ADB" -s "$SERIAL" shell am force-stop "$APP_ID" >/dev/null 2>&1 || true

  # Write directly into the app sandbox via `run-as` (most reliable on emulators/devices).
  # `files/pika_config.json` resolves to the same directory Android passes as `data_dir`.
  if ! printf '%s' "$json" | "$ADB" -s "$SERIAL" shell "run-as $APP_ID sh -c 'mkdir -p files && cat > files/pika_config.json'"; then
    echo "error: could not write app config via run-as" >&2
    echo "debug: run-as output:" >&2
    "$ADB" -s "$SERIAL" shell "run-as $APP_ID id" >&2 || true
    echo "hint: ensure you're running a debuggable build; if you previously installed a non-debuggable variant, run: adb uninstall $APP_ID" >&2
    exit 1
  fi
  # Verify read-back.
  "$ADB" -s "$SERIAL" shell "run-as $APP_ID sh -c 'cat files/pika_config.json >/dev/null'" >/dev/null
}

maybe_write_config

echo "launching $APP_ID"
# Prefer `am start` with a resolved launcher activity (more reliable than monkey).
resolved="$("$ADB" -s "$SERIAL" shell cmd package resolve-activity --brief -a android.intent.action.MAIN -c android.intent.category.LAUNCHER "$APP_ID" 2>/dev/null | tr -d '\r' | tail -n 1 || true)"
if [ -n "${resolved:-}" ] && echo "$resolved" | grep -q '/'; then
  "$ADB" -s "$SERIAL" shell am start -W -n "$resolved" >/dev/null
else
  "$ADB" -s "$SERIAL" shell am start -W -a android.intent.action.MAIN -c android.intent.category.LAUNCHER -n "$APP_ID"/.MainActivity >/dev/null
fi

# Confirm the process is actually running, otherwise fail with useful diagnostics.
for i in $(seq 1 20); do
  if "$ADB" -s "$SERIAL" shell pidof "$APP_ID" >/dev/null 2>&1; then
    echo "ok: android app launched"
    exit 0
  fi
  sleep 0.5
done

echo "error: app did not appear to start (pidof $APP_ID empty)" >&2
"$ADB" -s "$SERIAL" shell cmd package resolve-activity --brief -a android.intent.action.MAIN -c android.intent.category.LAUNCHER "$APP_ID" 2>&1 | sed -n '1,80p' >&2 || true
exit 1
