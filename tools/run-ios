#!/usr/bin/env bash
set -euo pipefail

# One-command iOS dev loop (simulator or device).
#
# Default: simulator.
#   ./tools/run-ios
#
# Physical device:
#   ./tools/run-ios --device
#   PIKA_IOS_DEVICE_UDID=<udid> ./tools/run-ios --device
#
# Notes:
# - Must run inside `nix develop` (or via direnv) so the Rust toolchain has iOS targets.
# - Requires a full Xcode install under /Applications for `xcrun`, `simctl`, `devicectl`.
#
# Optional relay overrides:
#   PIKA_RELAY_URLS="wss://relay.primal.net,wss://nos.lol,wss://relay.damus.io" ./tools/run-ios
#   PIKA_KEY_PACKAGE_RELAY_URLS="wss://nostr-pub.wellorder.net,..." ./tools/run-ios
# Disable auto defaults:
#   PIKA_NO_RELAY_OVERRIDE=1 ./tools/run-ios

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT"

# shellcheck disable=SC1091
source "$ROOT/tools/lib/dotenv.sh"
load_dotenv_no_override "$ROOT"

# If the user isn't in the devShell, re-exec under Nix for a consistent toolchain.
if [ -z "${IN_NIX_SHELL:-}" ] && [ "${PIKA_RUN_IOS_NO_NIX:-0}" != "1" ]; then
  qargs=()
  for a in "$@"; do qargs+=("$(printf '%q' "$a")"); done
  exec nix develop -c bash -lc "cd \"$ROOT\"; ./tools/run-ios ${qargs[*]}"
fi

IOS_BUNDLE_ID="${PIKA_IOS_BUNDLE_ID:-org.pikachat.pika}"
IOS_TEAM_ID="${PIKA_IOS_DEVELOPMENT_TEAM:-}"
MODE="sim"
CONSOLE="${PIKA_IOS_CONSOLE:-0}"
RELEASE=0
if [ "${PIKA_IOS_DEVICE:-0}" = "1" ]; then
  MODE="device"
fi
SIM_UDID="${PIKA_IOS_SIM_UDID:-}"

usage() {
  cat <<EOF
usage: ./tools/run-ios [--sim|--device] [--release] [--console] [--udid <udid>] [--list-devices]

Env:
  PIKA_IOS_BUNDLE_ID        (default: $IOS_BUNDLE_ID)
  PIKA_IOS_DEVELOPMENT_TEAM (required for --device; put it in .env to avoid typing)
  PIKA_IOS_DEVICE_UDID      (optional, for --device)
  PIKA_IOS_SIM_UDID         (optional, for --sim)
  PIKA_IOS_DEVICE=1         default to --device (if set, requires team id)
  PIKA_IOS_CONSOLE=1        default to --console
  PIKA_RUST_PROFILE         debug|release (default for run-ios: debug)
  PIKA_NO_RELAY_OVERRIDE=1  disable dev-friendly relay defaults
EOF
}

list_connected_iphones() {
  ./tools/xcode-run xcrun xctrace list devices 2>/dev/null | awk '
    $0 == "== Devices ==" { in_devices = 1; next }
    $0 == "== Simulators ==" { in_devices = 0; next }
    in_devices && $0 ~ /iPhone/ {
      print $0
    }
  '
}

choose_device_udid() {
  local lines count
  lines="$(list_connected_iphones)"
  count="$(echo "$lines" | sed '/^$/d' | wc -l | tr -d '[:space:]')"
  if [ "${count:-0}" = "1" ]; then
    echo "$lines" | sed -n 's/.*(\\([0-9A-Fa-f-]\\{25,\\}\\)).*/\\1/p'
    return 0
  fi
  if [ "${count:-0}" -gt 1 ]; then
    echo "error: multiple iPhones connected; choose one via --udid or PIKA_IOS_DEVICE_UDID:" >&2
    echo "$lines" | sed '/^$/d' | sed 's/^/  /' >&2
    exit 2
  fi
  echo ""
}

while [ $# -gt 0 ]; do
  case "$1" in
    --sim) MODE="sim" ;;
    --device) MODE="device" ;;
    --release) RELEASE=1 ;;
    --udid)
      shift
      if [ $# -lt 1 ]; then echo "error: --udid requires a value" >&2; exit 2; fi
      export PIKA_IOS_DEVICE_UDID="$1"
      MODE="device"
      ;;
    --list-devices)
      echo "iOS connected iPhones:"
      list_connected_iphones | sed '/^$/d' | sed 's/^/  /'
      exit 0
      ;;
    --console) CONSOLE=1 ;;
    -h|--help) usage; exit 0 ;;
    *)
      echo "error: unknown arg: $1" >&2
      usage >&2
      exit 2
      ;;
  esac
  shift
done

if [ "$RELEASE" = "1" ]; then
  export PIKA_RUST_PROFILE="release"
else
  export PIKA_RUST_PROFILE="${PIKA_RUST_PROFILE:-debug}"
fi
echo "rust profile: $PIKA_RUST_PROFILE"

default_relays() {
  echo "wss://relay.primal.net,wss://nos.lol,wss://relay.damus.io"
}

default_kp_relays() {
  echo "wss://nostr-pub.wellorder.net,wss://nostr-01.yakihonne.com,wss://nostr-02.yakihonne.com,wss://relay.satlantis.io"
}

effective_relays() {
  local relays="${PIKA_RELAY_URLS:-${PIKA_RELAY_URL:-}}"
  if [ -z "${relays:-}" ]; then relays="$(default_relays)"; fi
  echo "$relays"
}

effective_kp_relays() {
  local kp_relays="${PIKA_KEY_PACKAGE_RELAY_URLS:-${PIKA_KP_RELAY_URLS:-}}"
  if [ -z "${kp_relays:-}" ]; then kp_relays="$(default_kp_relays)"; fi
  echo "$kp_relays"
}

env_json_for_device() {
  if [ "${PIKA_NO_RELAY_OVERRIDE:-0}" = "1" ]; then
    # Empty dict.
    echo "{}"
    return 0
  fi
  local relays kp_relays
  relays="$(effective_relays)"
  kp_relays="$(effective_kp_relays)"
  local call_moq_url call_broadcast_prefix moq_probe_on_start notification_url
  # Default to the deployed anonymous MOQ relay; override with PIKA_CALL_MOQ_URL for local setups.
  call_moq_url="${PIKA_CALL_MOQ_URL:-https://us-east.moq.logos.surf/anon}"
  call_broadcast_prefix="${PIKA_CALL_BROADCAST_PREFIX:-pika/calls}"
  moq_probe_on_start="${PIKA_MOQ_PROBE_ON_START:-0}"
  notification_url="${PIKA_NOTIFICATION_URL:-}"
  python3 - <<PY
import json
d = {
  "PIKA_RELAY_URLS": "${relays}",
  "PIKA_KEY_PACKAGE_RELAY_URLS": "${kp_relays}",
  "PIKA_CALL_MOQ_URL": "${call_moq_url}",
  "PIKA_CALL_BROADCAST_PREFIX": "${call_broadcast_prefix}",
  "PIKA_MOQ_PROBE_ON_START": "${moq_probe_on_start}",
}
nu = "${notification_url}"
if nu:
    d["PIKA_NOTIFICATION_URL"] = nu
print(json.dumps(d))
PY
}

# Fail fast if iOS Simulator runtimes/devices are missing.
if [ "$MODE" = "device" ]; then
  # Ensure Xcode is installed.
  ./tools/xcode-dev-dir >/dev/null

  if [ -z "${IOS_TEAM_ID:-}" ]; then
    echo "error: PIKA_IOS_DEVELOPMENT_TEAM is required for --device" >&2
    echo "hint: add this to .env (gitignored) to make device runs one-command:" >&2
    echo "  PIKA_IOS_DEVELOPMENT_TEAM=YOUR_TEAM_ID" >&2
    echo "optional: if signing fails due to bundle id, set:" >&2
    echo "  PIKA_IOS_BUNDLE_ID=com.your.bundle" >&2
    exit 2
  fi

  UDID="${PIKA_IOS_DEVICE_UDID:-}"
  if [ -z "${UDID:-}" ]; then
    UDID="$(choose_device_udid)"
  fi
  if [ -z "${UDID:-}" ]; then
    echo "error: could not determine a connected iPhone UDID (set PIKA_IOS_DEVICE_UDID)" >&2
    exit 1
  fi

  # Faster dev loop defaults: debug Rust and only the required iOS Rust target.
  export PIKA_IOS_RUST_TARGETS="${PIKA_IOS_RUST_TARGETS:-aarch64-apple-ios}"

  # Build core xcframework + (re)generate the project.
  just ios-xcframework ios-xcodeproj

  # Build signed device .app (must unset LD/CC/CXX inside Nix shells).
  signing_settings=()
  signing_settings+=("DEVELOPMENT_TEAM=$IOS_TEAM_ID")
  signing_settings+=("CODE_SIGN_STYLE=Automatic")
  signing_settings+=("PIKA_APP_BUNDLE_ID=$IOS_BUNDLE_ID")
  signing_settings+=("PIKA_APP_GROUP=group.$IOS_BUNDLE_ID")

  ./tools/xcode-run xcodebuild \
    -project ios/Pika.xcodeproj \
    -scheme Pika \
    -configuration Debug \
    -sdk iphoneos \
    -destination "id=$UDID" \
    -derivedDataPath ios/build-device \
    -allowProvisioningUpdates \
    "${signing_settings[@]}" \
    build

  app_path="ios/build-device/Build/Products/Debug-iphoneos/Pika.app"
  if [ ! -d "$app_path" ]; then
    echo "error: missing built app at $app_path" >&2
    exit 1
  fi

  echo "installing app to device: $UDID"
  ./tools/xcode-run xcrun devicectl device install app -d "$UDID" "$app_path"

  env_json="$(env_json_for_device)"

  wait_for_unlocked() {
    # devicectl refuses to launch while locked; poll lock state for a short window so
    # `just run-ios` succeeds as soon as you unlock the device.
    local json tmp locked
    tmp="$(mktemp)"
    for i in $(seq 1 120); do
      rm -f "$tmp" >/dev/null 2>&1 || true
      if ./tools/xcode-run xcrun devicectl device info lockState -d "$UDID" --json-output "$tmp" >/dev/null 2>&1; then
        locked="$(python3 - <<PY 2>/dev/null || true
import json
p="${tmp}"
try:
  obj=json.load(open(p))
  # Best-effort: handle multiple devicectl JSON shapes across Xcode versions.
  def find_lock_state(o):
    if isinstance(o, dict):
      for k,v in o.items():
        lk = k.lower()
        if lk in ("passcoderequired",):
          return bool(v)
        if lk in ("unlockedsinceboot",):
          return not bool(v)
        if k.lower() in ("locked","islocked","devicelocked"):
          return bool(v)
        r=find_lock_state(v)
        if r is not None: return r
    if isinstance(o, list):
      for it in o:
        r=find_lock_state(it)
        if r is not None: return r
    return None
  v=find_lock_state(obj)
  if v is True: print("1")
  elif v is False: print("0")
except Exception:
  pass
PY
)"
        if [ "$locked" = "0" ]; then
          rm -f "$tmp" >/dev/null 2>&1 || true
          return 0
        fi
      fi
      if [ "$i" = "1" ]; then
        echo "waiting for device unlock (udid=$UDID)..." >&2
      fi
      sleep 1
    done
    rm -f "$tmp" >/dev/null 2>&1 || true
    return 1
  }

  if ! wait_for_unlocked; then
    echo "error: device appears locked; unlock it and re-run" >&2
    exit 1
  fi

  if [ "$CONSOLE" = "1" ]; then
    echo "launching $IOS_BUNDLE_ID (console attached)"
    ./tools/xcode-run xcrun devicectl device process launch -d "$UDID" \
      --environment-variables "$env_json" \
      --terminate-existing \
      --console \
      "$IOS_BUNDLE_ID"
  else
    echo "launching $IOS_BUNDLE_ID"
    ./tools/xcode-run xcrun devicectl device process launch -d "$UDID" \
      --environment-variables "$env_json" \
      --terminate-existing \
      "$IOS_BUNDLE_ID" >/dev/null
    echo "ok: ios app launched (device)"
  fi
  exit 0
fi

# Simulator mode.
udid=""
if [ -n "${SIM_UDID:-}" ]; then
  udid="$SIM_UDID"
  echo "using ios simulator udid: $udid"
  if ! ./tools/simctl list devices 2>/dev/null | grep -q "($udid)"; then
    echo "error: requested simulator udid not found: $udid" >&2
    echo "hint: run ./tools/pika-run ios list-targets to see available simulators" >&2
    exit 2
  fi
  ./tools/simctl boot "$udid" >/dev/null 2>&1 || true
  if ./tools/simctl help 2>/dev/null | grep -q "bootstatus"; then
    ./tools/simctl bootstatus "$udid" -b >/dev/null 2>&1 || true
  fi
else
  udid="$(./tools/ios-sim-ensure | sed -n 's/^ok: ios simulator ready (udid=\(.*\))$/\1/p')"
fi
if [ -z "${udid:-}" ]; then
  echo "error: could not determine simulator udid" >&2
  exit 1
fi

# Faster dev loop defaults: debug Rust and only the required simulator target.
if [ -z "${PIKA_IOS_SIM_ARCH:-}" ]; then
  if [ "$(uname -m)" = "x86_64" ]; then
    export PIKA_IOS_SIM_ARCH="x86_64"
  else
    export PIKA_IOS_SIM_ARCH="arm64"
  fi
fi
if [ -z "${PIKA_IOS_RUST_TARGETS:-}" ]; then
  if [ "$PIKA_IOS_SIM_ARCH" = "x86_64" ]; then
    export PIKA_IOS_RUST_TARGETS="x86_64-apple-ios"
  else
    export PIKA_IOS_RUST_TARGETS="aarch64-apple-ios-sim"
  fi
fi

just ios-build-sim

app_path="ios/build/Build/Products/Debug-iphonesimulator/Pika.app"
if [ ! -d "$app_path" ]; then
  # Backward-compatible fallback for older local build layouts.
  app_path="ios/build/Debug-iphonesimulator/Pika.app"
fi
if [ ! -d "$app_path" ]; then
  echo "error: missing built app at ios/build/Build/Products/Debug-iphonesimulator/Pika.app" >&2
  exit 1
fi

echo "installing app to simulator: $udid"
./tools/simctl install "$udid" "$app_path"

maybe_write_config() {
  # iOS passes `applicationSupportDirectory` as Rust `data_dir`, so we write:
  #   <app data container>/Library/Application Support/pika_config.json
  if [ "${PIKA_NO_RELAY_OVERRIDE:-0}" = "1" ]; then
    return 0
  fi

  local relays kp_relays
  relays="$(effective_relays)"
  kp_relays="$(effective_kp_relays)"
  local call_moq_url call_broadcast_prefix moq_probe_on_start notification_url
  # Default to the deployed anonymous MOQ relay; override with PIKA_CALL_MOQ_URL for local setups.
  call_moq_url="${PIKA_CALL_MOQ_URL:-https://us-east.moq.logos.surf/anon}"
  call_broadcast_prefix="${PIKA_CALL_BROADCAST_PREFIX:-pika/calls}"
  moq_probe_on_start="${PIKA_MOQ_PROBE_ON_START:-0}"
  notification_url="${PIKA_NOTIFICATION_URL:-}"

  local json
  json="$(
    python3 - <<PY
import json
d = {
  "disable_network": False,
  "relay_urls": [x.strip() for x in "${relays}".strip().split(",") if x.strip()],
  "key_package_relay_urls": [x.strip() for x in "${kp_relays}".strip().split(",") if x.strip()],
  "call_moq_url": "${call_moq_url}",
  "call_broadcast_prefix": "${call_broadcast_prefix}",
  "moq_probe_on_start": True if "${moq_probe_on_start}" == "1" else False,
}
nu = "${notification_url}"
if nu:
    d["notification_url"] = nu
print(json.dumps(d))
PY
  )"

  local container support_dir
  container="$(./tools/simctl get_app_container "$udid" "$IOS_BUNDLE_ID" data 2>/dev/null | tr -d '\r' | tail -n 1)"
  if [ -z "${container:-}" ] || [ ! -d "$container" ]; then
    echo "error: failed to locate simulator app container for $IOS_BUNDLE_ID (udid=$udid)" >&2
    exit 1
  fi

  support_dir="$container/Library/Application Support"
  mkdir -p "$support_dir"
  printf '%s' "$json" >"$support_dir/pika_config.json"
  echo "wrote relay override to: $support_dir/pika_config.json"
}

maybe_write_config

echo "launching $IOS_BUNDLE_ID"
./tools/simctl launch "$udid" "$IOS_BUNDLE_ID"

# Bring Simulator app to the foreground.
open -a Simulator >/dev/null 2>&1 || true

echo "ok: ios app launched (simulator)"
