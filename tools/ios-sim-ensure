#!/usr/bin/env bash
set -euo pipefail

# Ensures there is at least one booted iOS simulator device available.
#
# This does NOT download iOS simulator runtimes. If no runtimes are installed, it prints
# a clear error message and exits non-zero.

DEV_DIR="$(ls -d /Applications/Xcode*.app/Contents/Developer 2>/dev/null | sort | tail -n 1 || true)"
if [ -z "${DEV_DIR:-}" ]; then
  echo "error: Xcode not found under /Applications" >&2
  exit 1
fi
export DEVELOPER_DIR="$DEV_DIR"

SIMCTL="$DEV_DIR/usr/bin/simctl"

if [ -z "$("$SIMCTL" list runtimes | sed -n '2,$p' | tr -d '[:space:]')" ]; then
  # Keep this check in one place so `just run-ios` and `just ios-ui-test`
  # can give consistent guidance.
  ./tools/ios-runtime-doctor >&2 || true
  exit 1
fi

# Pick the latest available iOS runtime identifier. `simctl list runtimes` prints both
# a human-readable version/build in parentheses and the identifier after " - ".
# Example:
#   iOS 18.6 (18.6 - 22G86) - com.apple.CoreSimulator.SimRuntime.iOS-18-6
runtime_id="$(
  "$SIMCTL" list -j runtimes | python3 -c '
import json,sys,re
j=json.load(sys.stdin)
r=[]
for rt in j.get("runtimes",[]):
  ident=rt.get("identifier") or ""
  name=rt.get("name") or ""
  avail=rt.get("isAvailable")
  if not name.startswith("iOS "):
    continue
  if avail is False:
    continue
  m=re.search(r"iOS-(\d+)-(\d+)$", ident)
  if not m:
    continue
  r.append((int(m.group(1)), int(m.group(2)), ident))
r.sort()
sys.stdout.write(r[-1][2] if r else "")
'
)"
if [ -z "${runtime_id:-}" ]; then
  echo "error: Failed to determine an iOS runtime identifier from simctl." >&2
  "$SIMCTL" list runtimes >&2 || true
  exit 1
fi

device_type_id="$("$SIMCTL" list devicetypes | awk -F '[()]' '/iPhone 15/ {print $2; exit}')"
if [ -z "${device_type_id:-}" ]; then
  # Fallback to first iPhone device type if "iPhone 15" isn't available.
  device_type_id="$("$SIMCTL" list devicetypes | awk -F '[()]' '/iPhone/ {print $2; exit}')"
fi
if [ -z "${device_type_id:-}" ]; then
  echo "error: Failed to determine an iPhone device type id from simctl." >&2
  "$SIMCTL" list devicetypes >&2 || true
  exit 1
fi

device_name="Pika iPhone 15"
udid="$("$SIMCTL" list devices | awk -F '[()]' -v name="$device_name" '$0 ~ name {print $2; exit}')"
if [ -z "${udid:-}" ]; then
  udid="$("$SIMCTL" create "$device_name" "$device_type_id" "$runtime_id" | tr -d '[:space:]')"
  echo "created simulator: $device_name ($udid)"
fi

"$SIMCTL" boot "$udid" >/dev/null 2>&1 || true
if "$SIMCTL" help 2>/dev/null | grep -q "bootstatus"; then
  "$SIMCTL" bootstatus "$udid" -b >/dev/null 2>&1 || true
fi

# XCUITest bundles run inside the simulator and do not reliably inherit the host
# environment. When running E2E suites that require a stable identity (e.g. an
# allowlisted nsec for public relays), propagate it into the simulator's launchd
# environment so the test runner can read it via ProcessInfo.environment.
maybe_nsec="${PIKA_UI_E2E_NSEC:-${PIKA_TEST_NSEC:-}}"
maybe_bot_npub="${PIKA_UI_E2E_BOT_NPUB:-}"
maybe_relays="${PIKA_UI_E2E_RELAYS:-}"
maybe_kp_relays="${PIKA_UI_E2E_KP_RELAYS:-}"

# Notes:
# - XCUITest runs inside the simulator and does not reliably inherit the host env.
# - `launchctl setenv` makes these visible to the test runner via ProcessInfo.environment.
if [ -n "${maybe_nsec:-}" ]; then
  "$SIMCTL" spawn "$udid" launchctl setenv PIKA_UI_E2E_NSEC "$maybe_nsec" >/dev/null 2>&1 || true
  "$SIMCTL" spawn "$udid" launchctl setenv PIKA_TEST_NSEC "$maybe_nsec" >/dev/null 2>&1 || true
fi
if [ -n "${maybe_bot_npub:-}" ]; then
  "$SIMCTL" spawn "$udid" launchctl setenv PIKA_UI_E2E_BOT_NPUB "$maybe_bot_npub" >/dev/null 2>&1 || true
fi
if [ -n "${maybe_relays:-}" ]; then
  "$SIMCTL" spawn "$udid" launchctl setenv PIKA_UI_E2E_RELAYS "$maybe_relays" >/dev/null 2>&1 || true
fi
if [ -n "${maybe_kp_relays:-}" ]; then
  "$SIMCTL" spawn "$udid" launchctl setenv PIKA_UI_E2E_KP_RELAYS "$maybe_kp_relays" >/dev/null 2>&1 || true
fi

echo "ok: ios simulator ready (udid=$udid)"
